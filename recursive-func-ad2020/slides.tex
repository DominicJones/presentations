% \documentclass{beamer}
\documentclass[xcolor=dvipsnames]{beamer}
\usefonttheme{serif}
%% \usecolortheme[named=Blue]{structure}
\setbeamersize{text margin left=30mm, text margin right=30mm}
\useoutertheme{infolines}
%% \usetheme[height=7mm]{Rochester}
\usetheme{Pittsburgh}
\setbeamertemplate{items}[ball]
\setbeamertemplate{blocks}[rounded][shadow=true]
\setbeamertemplate{navigation symbols}{}

\usepackage[utf8x]{inputenc}
%% \usepackage{default}
\usepackage[english]{babel}
\usepackage{geometry}
%% \usepackage{fullpage}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{listings}
\usepackage{pxfonts}
%% \usepackage{caption}
\usepackage[labelformat=empty]{caption}
\usepackage{amsmath}

%% \usepackage{xcolor}
%% \usepackage{newunicodechar}
%% \newcommand\Warning{%
%%  \makebox[1.4em][c]{%
%%  \makebox[0pt][c]{\raisebox{.1em}{\small!}}%
%%  \makebox[0pt][c]{\color{red}\Large$\bigtriangleup$}}}%
%% \newunicodechar{âš }{\Warning}


%% \usepackage{color}
%% \usepackage{graphicx}
%% \usepackage{natbib}
%% \usepackage{array}
%% \usepackage{booktabs}
%% \usepackage{tabu}
%% \usepackage[utf8]{inputenc}
%% \usepackage{fancyhdr}
%% \usepackage{float}
%% \usepackage{subfigure}
%% \usepackage{titlesec}

\setbeamertemplate{headline}{}
\setbeamertemplate{footline}[frame number]{}
\setbeamertemplate{navigation symbols}{}
\setbeamertemplate{footline}{}
\setbeamertemplate{footline}[frame number]


\def\CCT{{C\nolinebreak[4]\hspace{-.05em}\raisebox{.4ex}{\tiny\bf ++}}}
\def\CC{{C\nolinebreak[4]\hspace{-.05em}\raisebox{.4ex}{\small\bf ++}}}


\definecolor{lstgray}{gray}{0.93}
\definecolor{strgray}{gray}{0.4}

\lstset{ %
  escapechar=@,
  language=C++,
  basicstyle=\footnotesize\ttfamily,
  %% basicstyle=\ttfamily,
  stringstyle=\color{strgray}\ttfamily,
  commentstyle=\color{OliveGreen}\ttfamily,
  %% morecomment=[l][\color{red}]{\#},
  morecomment=[l][\color{blue}]{\#},
  backgroundcolor=\color{lstgray},
  frame=f,
  frameround=ffff,
  tabsize=2,
  breaklines=true,
  breakatwhitespace=false,
  showspaces=false,
  showstringspaces=false,
  xleftmargin=5pt,
  xrightmargin=5pt,
  morekeywords={decltype,sizeof,constexpr},
  %% keywordstyle=\color{red},
  keywordstyle=\bfseries\color{black}\ttfamily,
  keywords=[2]{Option,PRIMAL,TANGENT,ADJOINT},
  keywordstyle=[2]\bfseries\color{OliveGreen}\ttfamily,
  keywords=[3]{Drv,mode,SDrv,EDrv,DrvFieldLoop\_begin,DrvFieldLoop\_end,drv,find\_DrvMode,DrvMode,edrv,primal,DrvVariadicNode,ScopedExprBinding},
  keywordstyle=[3]\color{blue}\ttfamily,
  keywords=[4]{Hyp,hyp,MeanSd,mean\_sd,evaluate},
  keywordstyle=[4]\color{red}\ttfamily,
}

\def\redcolor{\color{red}}
\def\bluecolor{\color{blue}}
\def\blackcolor{\color{black}}
\def\graycolor{\color{gray}}
\def\greencolor{\color{OliveGreen}}


\def\sectionname{\translate{Section}}
\def\insertsectionnumber{\arabic{section}}
\setbeamertemplate{section page}
{
  \begin{centering}
    \begin{beamercolorbox}[sep=4pt,center]{part title}
      \usebeamerfont{section title}\insertsection\par
    \end{beamercolorbox}
  \end{centering}
}
\def\sectionpage{\usebeamertemplate*{section page}}


\AtBeginSection{\frame{\sectionpage}}


\title{Recursive compile-time differentiation}
\subtitle{Handling nested functions}
\author{Dominic Jones}
\date{\small{July 2020}}



\begin{document}
\begin{frame}[plain]
  \titlepage
\end{frame}


\begin{frame}[fragile]{Introduction}
\begin{itemize}
\item The compile time differentiation of a {\CC} function which only calls built-in functions has been demonstrated in other talks \vspace{3mm}
\item This talk describes the approach for differentiating a function which may call any other function \vspace{3mm}
\item The approach produces very efficient code, and compiles relatively quickly \vspace{3mm}
\item Siemen's Simcenter STAR-CCM+ simulation software has an implementation of this approach, and is used to differentiate the Spalart Allmaras turbulence model, among other things \vspace{3mm}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Perfect forwarding}
\begin{lstlisting}
template<class OP, class T>
struct Unary { Unary(T &&v) {} };
\end{lstlisting}

\begin{lstlisting}
class Sqrt;

template<class T>
auto sqrt(T &&v)
{
  return Unary<Sqrt, T>(std::forward<T>(v));
}
\end{lstlisting}

\begin{lstlisting}
float const a0{1};
auto a1 = sqrt(a0);        // Unary<Sqrt, float const &>

float b0{1};
auto b1 = sqrt(b0);        // Unary<Sqrt, float &>

auto c1 = sqrt(float{1});  // Unary<Sqrt, float>
\end{lstlisting}
\end{frame}


\section{Built in functions}


\begin{frame}[fragile]{Hypotenuse}
\begin{equation*}
  r = \sqrt{a^2 + b^2}
\end{equation*}

\begin{lstlisting}
float a = 3;
float b = 4;
float r;

{
  float d = a*a + b*b;
  r = sqrt(d);
}

std::cout << r << std::endl; // r = 5
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Primal of Hypotenuse}
\begin{equation*}
  r = \sqrt{a^2 + b^2}
\end{equation*}

\begin{lstlisting}
float a = 3;
float b = 4;
float r;

auto constexpr mode = DrvMode::PRIMAL;

Drv<mode, float>  a_{a};
Drv<mode, float>  b_{b};
Drv<mode, float&> r_{r};

{
  EDrv<mode, float> d = a_*a_ + b_*b_;
  r_ = drv::sqrt(d);
}

std::cout << r << std::endl; // r = 5
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Tangents of Hypotenuse}
\begin{equation*}
  \frac{d r}{d a}
\end{equation*}

\begin{lstlisting}
float a = 3, a_drv = 1; // w.r.t. `a'
float b = 4, b_drv = 0;
float        r_drv;

auto constexpr mode = DrvMode::TANGENT;

Drv<mode, float>  a_{a, a_drv};
Drv<mode, float>  b_{b, b_drv};
Drv<mode, float&> r_{r_drv};

{
  EDrv<mode, float> d = a_*a_ + b_*b_;
  r_ = drv::sqrt(d);
}

std::cout << r_drv << std::endl; // dr/da = 0.6
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Tangents of Hypotenuse}
\begin{equation*}
  \frac{d r}{d b}
\end{equation*}

\begin{lstlisting}
float a = 3, a_drv = 0;
float b = 4, b_drv = 1; // w.r.t. `b'
float        r_drv;

auto constexpr mode = DrvMode::TANGENT;

Drv<mode, float>  a_{a, a_drv};
Drv<mode, float>  b_{b, b_drv};
Drv<mode, float&> r_{r_drv};

{
  EDrv<mode, float> d = a_*a_ + b_*b_;
  r_ = drv::sqrt(d);
}

std::cout << r_drv << std::endl; // dr/db = 0.8
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Adjoint of Hypotenuse}
\begin{equation*}
\begin{bmatrix}
\frac{d r}{d a} & \frac{d r}{d b}
\end{bmatrix}^T
\end{equation*}

\begin{lstlisting}
float a = 3, a_drv = 0;
float b = 4, b_drv = 0;
float        r_drv = 1; // w.r.t. `r'

auto constexpr mode = DrvMode::ADJOINT;
Drv<mode, float>  a_{a, a_drv};
Drv<mode, float>  b_{b, b_drv};
Drv<mode, float&> r_{r_drv};

// scope is required
{
  EDrv<mode, float> d = a_*a_ + b_*b_;
  r_ = drv::sqrt(d);
}

std::cout << a_drv << std::endl; // dr/da = 0.6
std::cout << b_drv << std::endl; // dr/db = 0.8
\end{lstlisting}
\end{frame}


\section{User defined functions}


\begin{frame}[fragile]{As a subrountine}
\begin{lstlisting}
template<DrvMode::Option mode> void
hyp(Drv<mode, float> const &a,
    Drv<mode, float> const &b,
    Drv<mode, float&> r)
{
  EDrv<mode, float> d = a*a + b*b;
  r = drv::sqrt(d);
}
\end{lstlisting}

\begin{lstlisting}
Drv<mode, float>  a_{a, a_drv};
Drv<mode, float>  b_{b, b_drv};
Drv<mode, float&> r_{r_drv};

hyp(a_, b_, r_); // subroutine style (not much use...)
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{As a function}
\begin{lstlisting}
struct Hyp {
  template<DrvMode::Option mode> static void
  evaluate(Drv<mode, float> const &a,
           Drv<mode, float> const &b,
           Drv<mode, float&> r)
  {
    EDrv<mode, float> d = a*a + b*b;
    r = drv::sqrt(d);
\end{lstlisting}

\begin{lstlisting}
template<class E0, class E1> auto hyp(E0 &&e0, E1 &&e1) ->
DrvVariadicNode<find_DrvMode<E0, E1>::result(), // mode
                decltype(primal(e0 + e1)),      // float
                ScopedExprBinding<Hyp>, E0, E1>
{
  return {std::forward<E0>(e0), std::forward<E1>(e1)};
\end{lstlisting}

\begin{lstlisting}
Drv<mode, float>  a_{a, a_drv};
Drv<mode, float>  b_{b, b_drv};
Drv<mode, float&> r_{r_drv};

r_ = hyp(a_, b_); // functional style (very useful!)
\end{lstlisting}
\end{frame}


\begin{frame}[fragile]{Continuation with functions}
\begin{lstlisting}
Drv<mode, float>  a_{a, a_drv};
Drv<mode, float>  b_{b, b_drv};
Drv<mode, float&> r_{r_drv};

{
  EDrv<mode, float> r  = hyp(a_, b_);
  EDrv<mode, float> r2 = drv::pow(r, 2);
  r_ = r2;
}
\end{lstlisting}

\begin{itemize}
\item {\color{red}\texttt{hyp}} can be used just like any built-in function, such as \texttt{{\color{blue}drv}::pow}
\end{itemize}
\end{frame}


\section{Beyond the basics}


\begin{frame}[fragile]{Multiple results}
\begin{lstlisting}
MeanSd::
evaluate(...,
         Drv<mode, std::tuple<float, float> &> r)
{
  EDrv<mode, float> mean = a + b / 2;
  EDrv<mode, float> sd2 = drv::pow(a - mean, 2) +
                          drv::pow(b - mean, 2);
  r.at<1>() = drv::sqrt(sd2 / 2);
  r.at<0>() = mean;
\end{lstlisting}

\begin{lstlisting}
{
  EDrv<mode, std::tuple<float, float>> r = mean_sd(a_, b_);
  EDrv<mode, float> mean = r.at<0>();
  EDrv<mode, float> sd = r.at<1>();
  ...
\end{lstlisting}

\begin{itemize}
\item {\color{red}\texttt{mean\_sd}} packages outputs with \texttt{std::tuple} and accesses them with \texttt{result.at<I>()}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Passive variables}
\begin{lstlisting}
Drv<mode, float>  a_{a, a_drv};
Drv<mode, float&> r_{r_drv};

{
  EDrv<mode, float> r  = hyp(a_, b);     // `b' is passive
  EDrv<mode, float> r2 = drv::pow(r, 2); // `2' is passive
  r_ = r2;
}
\end{lstlisting}

\begin{itemize}
\item {At least one parameter of every function needs to be an active variable or expression (i.e. a \texttt{Drv<>} or \texttt{EDrv<>})}
\end{itemize}
\end{frame}


\section{\texttt{l-value} types}


\begin{frame}[fragile]{Named approach (using heap \& stack)}
\begin{lstlisting}
{
  EDrv<mode, float> d = a*a + b*b;
  r = drv::sqrt(d);
}
\end{lstlisting}

\begin{itemize}
\item \texttt{EDrv<>} doesn't know the type of the expression: \texttt{a*a + b*b} \vspace{3mm}
\item In order for \texttt{EDrv<>} to make a copy of the expression so as to evaluate its adjoint during destruction, \texttt{OpaqueObjectManager} is used \vspace{3mm}
\item The manager provides a stack buffer. If the expression is larger than the buffer then the heap is used \vspace{3mm}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Named approach (using stack only)}
\begin{lstlisting}
{
  SDrv<mode, float> d = a*a + b*b;
  r = drv::sqrt(d);
}
\end{lstlisting}

\begin{itemize}
\item \texttt{SDrv<>} doesn't know the type of the expression: \texttt{a*a + b*b} \vspace{3mm}
\item In order for \texttt{SDrv<>} to make a copy of the expression so as to evaluate its adjoint during destruction, \texttt{OpaqueObjectManager} is used \vspace{3mm}
\item The manager provides a stack buffer. If the expression is larger than the buffer then there is a {\color{red}\texttt{static\_assert}} during compilation \vspace{3mm}
\end{itemize}
\end{frame}


\begin{frame}[fragile]{\texttt{auto} approach}
\begin{lstlisting}
{
  auto d = edrv(a*a + b*b);
  r = drv::sqrt(d);
}
\end{lstlisting}

\begin{itemize}
\item \texttt{auto} knows the type of the expression: \texttt{a*a + b*b} \vspace{3mm}
\item \texttt{auto} holds a copy of the expression so as to evaluate its adjoint during destruction \vspace{3mm}
\item \texttt{auto} and \texttt{edrv} go together, rather like \texttt{std::unique\_ptr} and \texttt{std::make\_unique} \vspace{3mm}
\item This approach produces the most efficient code
\end{itemize}
\end{frame}


\begin{frame}[fragile]{Overview}
\begin{itemize}
\item The idea is to be able to annotate original code in order to generate its derivative \vspace{3mm}
\item Code must be `pure functional', i.e. all variables ought to be \texttt{const} qualified \vspace{3mm}
\item User defined primitives supported, like \texttt{Vector<N,T>}, \texttt{Tensor<N,T>} \vspace{3mm}
\item Virtual functions are supported \vspace{3mm}
\item \texttt{auto} return type is supported (instead of \texttt{EDrv<>}) \vspace{3mm}
\end{itemize}
\end{frame}


%%
\begin{frame}[plain]
  \titlepage
\end{frame}


\end{document}
